package ai.ragu.charactermanager.app;


import ai.ragu.charactermanager.dto.CharacterDto;
import ai.ragu.charactermanager.mapper.CharacterMapper;
import ai.ragu.charactermanager.sheet.CharacterSheet;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.module.jsonSchema.JsonSchema;
import com.fasterxml.jackson.module.jsonSchema.JsonSchemaGenerator;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Mixin;
import picocli.CommandLine.Option;
import picocli.CommandLine.ParseResult;

import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.invoke.MethodHandles;
import java.nio.file.Files;
import java.nio.file.Path;

@SuppressWarnings("ALL")
@Command(name = "characterManager", subcommands = {
        CharacterManagerCLIApp.Compile.class,
        CharacterManagerCLIApp.DtoSchema.class,
        CharacterManagerCLIApp.SheetSchema.class,
})
public class CharacterManagerCLIApp {
    private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    private static final CharacterManagerCLIApp app = new CharacterManagerCLIApp();

    public static final int DEFAULT_TIME_LIMIT_MINUTES = 10;

    private static final String DATE_TIME_PATTERN = "yyyy-MM-dd-HH-mm-ss";

    private static class InputFile {
        @Option(
                names = {"-i", "--inputFile"},
                paramLabel = "INPUT_FILE",
                description = "The input file",
                required = true
        )
        private Path path;
    }

    private static class OutputDir {
        @Option(
                names = {"-o", "--output"},
                paramLabel = "OUTPUT_DIR",
                description = "The output directory",
                required = true
        )
        private Path path;
    }

    private static class Help {
        @Option(names = {"-h", "--help"}, usageHelp = true, description = "Show this help message and exit.")
        private boolean helpRequested = false;
    }

    @Command(
            name = "dtoSchema",
            description = "Generate the character DTO JSON schema"
    )
    static class DtoSchema {
        @Mixin
        OutputDir outputDir;

        @Mixin
        Help help;
    }

    @Command(
            name = "sheetSchema",
            description = "Generate the character sheet JSON schema"
    )
    static class SheetSchema {
        @Mixin
        OutputDir outputDir;

        @Mixin
        Help help;
    }

    @Command(
            name = "compile",
            description = "Compile the given character in the sheet JSON format"
    )
    static class Compile {
        @Mixin
        InputFile inputFile;
        @Mixin
        OutputDir outputDir;

        @Option(
                names = {"--debug"},
                paramLabel = "GENERATE_DEBUG_FILES",
                description = "A flag to indicate that intermediate debug files should be written"
        )
        private boolean debug;

        @Mixin
        Help help;
    }

    @Mixin
    private Help help;

    /**
     * The entry point. The method parses command line arguments and executes the appropriate actions.
     *
     * @param args the command line args, as an array of strings
     */
    public static void main(String[] args) {
        CommandLine commandLine = new CommandLine(app);
        ParseResult parseResult;

        try {
            parseResult = commandLine.parseArgs(args);
        } catch (Exception e) {
            logger.error(e.getLocalizedMessage());
            return;
        }

        handleParseResult(parseResult);
    }

    /**
     * Executes the appropriate command instructed in the command line arguments.
     *
     * @param parseResult the parsed command line arguments, as generated by PicoCLI
     */
    private static void handleParseResult(ParseResult parseResult) {
        for (CommandLine parsed : parseResult.asCommandLineList()) {
            if (parsed.isUsageHelpRequested()) {
                parsed.usage(System.out);
                return;
            } else if (parsed.isVersionHelpRequested()) {
                parsed.printVersionHelp(System.out);
                return;
            }
        }

        ParseResult subCommand = parseResult.subcommand();
        if (subCommand.commandSpec().userObject().getClass().equals(Compile.class)) {
            Compile compile = (Compile) subCommand.commandSpec().userObject();
            createOutputDirectory(compile.outputDir.path);
            Path inputFilePath = compile.inputFile.path;
            String noExtName = FilenameUtils.removeExtension(compile.inputFile.path.toFile().getName());
            Path outputFilePath = Path.of(compile.outputDir.path.toString(), noExtName + ".sheet.json");
            compileCharacter(inputFilePath, outputFilePath);
        } else if (subCommand.commandSpec().userObject().getClass().equals(DtoSchema.class)) {
            DtoSchema dtoSchema = (DtoSchema) subCommand.commandSpec().userObject();
            createOutputDirectory(dtoSchema.outputDir.path);
            String schemaFilename = Path.of(dtoSchema.outputDir.path.toString(), "dto-schema.json").toString();
            generateSchema(CharacterSheet.class, schemaFilename);
        }  else if (subCommand.commandSpec().userObject().getClass().equals(SheetSchema.class)) {
            SheetSchema sheetSchema = (SheetSchema) subCommand.commandSpec().userObject();
            createOutputDirectory(sheetSchema.outputDir.path);
            String schemaFilename = Path.of(sheetSchema.outputDir.path.toString(), "sheet-schema.json").toString();
            generateSchema(CharacterSheet.class, schemaFilename);
        }
    }

    /**
     * Compiles a character DTO into its sheet representation.
     *
     * @param inputFilePath the full path to the character DTO JSON file to read
     * @param outputFilePath the full path to the character sheet JSON file to write
     */
    private static void compileCharacter(Path inputFilePath, Path outputFilePath) {
        logger.info("Compiling the character into sheet JSON format...");
        CharacterDto characterDto;
        try {
            try (InputStream fileStream = new FileInputStream(inputFilePath.toFile())) {
                ObjectMapper objectMapper = new ObjectMapper();
                characterDto = objectMapper.readValue(fileStream, CharacterDto.class);
                logger.info(String.format("Character JSON file loaded: %s", inputFilePath));
            }
            CharacterSheet characterSheet = CharacterMapper.INSTANCE.map(characterDto);
            try (FileWriter file = new FileWriter(outputFilePath.toFile())) {
                ObjectMapper objectMapper = new ObjectMapper();
                objectMapper.writerWithDefaultPrettyPrinter().writeValue(file, characterDto);
                logger.info(String.format("Character sheet JSON file generated: %s", outputFilePath.toFile()));
            }
        } catch (IOException exception) {
            logger.error(exception.getLocalizedMessage());
        }
    }

    /**
     * Generates the JSON schema for the given class (assuming the proper annotations are present).
     *
     * @param cls the class of which the schema should be generated
     * @param outputFilePath the full path to the JSON schema file to write
     */
    private static void generateSchema(Class cls, String schemaFilename) {
        ObjectMapper mapper = new ObjectMapper();
        JsonSchemaGenerator generator = new JsonSchemaGenerator(mapper);
        JsonSchema jsonSchema = null;
        try {
            jsonSchema = generator.generateSchema(cls);
        } catch (JsonMappingException e) {
            logger.error(e.getLocalizedMessage());
        }

        try (FileWriter file = new FileWriter(schemaFilename)) {
            logger.info("Generating sheet schema...");
            String obj = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonSchema);
            file.write(obj);
            logger.info(String.format("Schema generated in: %s", schemaFilename));
        } catch (IOException exception) {
            logger.error(exception.getLocalizedMessage());
        }
    }

    private static void createOutputDirectory(Path targetPath){
        if (!Files.exists(targetPath)) {
            try {
                Files.createDirectories(targetPath);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
